Documentatie:  

   Deoarece a trebuit sa folosim protocolul de comunicatie SPI jocul a fost impartit in alte 2 programe Slave si Master. Pentru o mai buna intelegere o sa fie explicate pe rand.  
   Programul pentru Slave:  
   In setup() am setat pinii led-urilor RGB ca output si i-am initilalizat cu valoare LOW. Deoarece comunicarea are loc folosind SPI am setat programul ca slave. Acesta primind valori de la programul master folosind o functie rutina de intrerupere (ISR).   
   Butoanele folosite in joc au fost multiplexate, astfel pentru a determina ce buton a fost apasat vom folosi analogRead(). In functie de limita maxima a valorii analogice a fiecarui buton se va stabili ce buton a fost apasat. Daca butonul apasat a trecut peste verificarea de debounce atunci vom trimite date (i.e. buton apasat) catre master prin SPI. Pentru a transmite butonul apasat a trebuit sa fie implementata o intrerupere generata de catre slave catre master (“digitalWrite(masterInterruptPin, pinChangeInterruptState”). Astfel, datele vor fi transmise atunci cand se schimba starea pinului corespunzator intreruperii master-ului (“ pinChangeInterruptState = !pinChangeInterruptState”).  In master a fost definita o rutina de intreruperi (“attachInterrupt(digitalPinToInterrupt(2), spiTransfer, CHANGE)”) de la slave.  
   In functia de intrerupere de la master la slave se va primi valoare led-ului ca va trebui aprins pentru continuarea jocului. Led-ul ce va urma sa fie aprins se determina printr-o serie de if-uri. Intr-o runda led-ul RGB al jucatorului inactiv va trebui sa fie stins.  
   Programul pentru master:  
   In setup() am setat instructiunile corespunzatoare pentru rolul de master in procesul SPI, am initilalizat lcd-ul, random seed si servo-ul. Deoarece trebuie sa primim valoarea butonul apasat de la slave, am realizat si o intrerupere a masterului atunci cand slave-ul doreste sa trimita date prin SPI. Programul slave va activa intreruperea prin modificarea starii pinului corespunzator intreruperii. In urma acesteia masterul va primi butonul apasat si se poate continua logica jocului.  
   Inainte de inceputul jocului se va afisa un mesaj pe lcd pentru inceperea acestuia. De asemenea, tot in aceasta faza se pot seta numele celor doi playeri, acestea fiind citite prin serial si afisate la ecranul lcd pe parcursul jocului impreuna cu scorul fiecaruia. In cazul in care prin SPI masterul primeste de la slave butonul de start, se va incepe un nou joc doar in cazul in care starea acestuia este inactiva. Astfel, variabilele precum scorul celor doi playeri, counterul timerului vor fi resetate la 0 si starea jocului va deveni activa. In cazul in care jocul este activ, la fiecare intrerupere a timerului, servo-ul se va roti cu un anumit numar de grade. Timerul folosit este Timer 1 configurat sa aiba o frecventa de 1Hz, deci la fiecare secunda are loc o intrerupere. In cazul in care counterul corespunzator timerului depaseste timpul total al jocului, jocul se termina. Revenim la cazul in care jocul este activ, pentru a incepe o noua runda am folosit conditia - daca counterul este divizibil cu timpul rundei atunci se va schimba runda si playerul-. De asemenea, exista si variabila oneTime folosita doar pentru a ne asigura ca playerul nu se va schimba de mai multe ori pe secunda in care este adevarata conditia anterioara. Nu exista un timp de asteptare intre runde, pentru a avea o dificultate mai crescuta. Deoarece in joc avem doi playeri am creat doua cazuri de gestionare a jocului. Acestea fiind aproape identice doar valorile led-urilor si butoanelor ce sunt comparate vor fi schimbate, deoarece ne dorim ca in cazul in care playerul oponent apasa un buton de pe partea sa atunci cand nu este runda sa, sa nu poata avea efect asupra jocului playerului curent.   
   Daca jocul este activ si butonul apasat este cel corect (matched). Atunci o sa incepem transmisia de date prin SPI catre slave, in care vom trimite urmatorul led, led-ul fiind generat random. In cazul in care primim o noua valoare a butonului de la slave vom verifica daca perechea led random, buton apasat este cea corecta si vom calcula scorul in functie de viteza de reactie a jucatorului, scorul fiind si actualizat pe lcd. 
La finalul jocului se va afisa pentru cateva secundecastigatorul jocului, si se va reveni la ecranul de start game, servo-ul va trece inapoi la 0 grade si se va putea reintroduce alte nume de player.  
