Documentatie  
   In partea de inceput a programului am definit pinii corespunzatori led-ului RGB si a butoanelor. Pinii pentru led-ul RGB au fost setati pe output, iar butoanele pe input si cu rezistenta de pull-up activata. Deoarece in acest proiect gestionarea apasarii butoanelor se realizeaza folosind intreruperi, a fost necesar sa le definim si include in setup(), rutinele de tratare a interuperilor celor doua butoane sunt debounceMode() si debounceRound(), ce vor fi activate la apasarea butonului (falling). In cazul functiei debounceRound() s-a realizat si verificarea de debounce a butonului, iar daca apasarea butonului nu a fost determinata de fenomenul de debounce se va schimba starea in care se afla jocul (pentru debounce am verificat daca timpul intre apasarea anterioara a butonului si apasarea actuala al acestuia este mai mare decat un anumit interval). Pentru functia debounceMode(), am inclus si partea de debounce a butonului, dar in cazul acestei functii se va putea realiza schimbarea modului doar daca runda nu este activa, daca jocul este insa in repaus, la apasarea butonului se va cicla intre modurile de dificultate ale rundei (easy=0-medium=1-hard=2).  
   Daca exista o schimbare a starii in care se afla jocul, din repaus in activ si invers vom avea 2 cazuri. Primul caz, daca starea actuala este activa atunci intializam scorul cu 0 si apelam functia blinkLED(). Functia implementeaza logica de clipire a led-ului, in care se schimba starea led-ului la un anumit interval de timp si se realizeaza de un numar exact de ori, stabilit de catre counter pentru a respecta conditia de a clipi timp de 3 secunde. La finalul partii de clipire, led-ului va ramane verde, iar in functie de modul in care se afla runda se va seta variabila interruptCount cu o anumita valoare corespunzatoare modului in care se afla jocul, folosita pentru a executa codul de generare a cuvintelor imediat dupa terminarea partii de clipire a led-ului. In al doilea caz, daca jocul este in repaus se va putea alege dificultatea urmatoarei runde, iar alegerea se va afisa in terminal.  
   Deoarece o runda trebuie sa tina doar 30 de secunde, am folosit un timer, mai exact Timer1 pe care l-am configurat pentru a avea o frecventa de 1 Hz. Atunci cand are loc o intrerupere a acestuia in cazul in care runda este activa se va incrementa counterul asociat acesteia, interruptRoundCounter, altfel counterul va devenii 0. Daca runda este inca activa, dar counterul a ajuns la valoarea sa de final (interruptRoundCounter == timeRoundCount) jocul va trece in starea de repaus, - timeRoundCount memoreaza de cate ori trebuie sa fi avut loc o intrerupere pentru a ajunge la finalul rundei-.  
   Timer2 a fost utilizat pentru a stabilii frecventa de aparitie a cuvintelor, a fost setat pe 500 Hz, ce inseamna ca ISR-ul corespunzator va fii apelat la un interval de 2 ms. In ISR se va incrementa un counter (interruptCount) ce va fi util pentru gestionarea aparitiei cuvintelor in functie de mod.  
   Fiecare dificultate a jocului ii corepunde o anumita valoare, iar variabila interruptCount va fi comparata cu o constanta ce reprezinta de cate trebuie sa se intre in ISR pentru a se genera un cuvant -in cazul lui easy frecventa de aparitie a cuvantului va fi la 8s i.e. 4000 ori, pentru medium la 4s i.e. 2000 de ori si pentru hard la 2s, i.e. 1000 ori-. In cazul in care una dintre conditiile anterioare (interruptCount >= easyCount && mode == easy) || (interruptCount >= mediumCount && mode == medium) || (interruptCount >= hardCount && mode == hard) este satisfacuta se va genera un cuvant random. Variabila interruptCount va trece in 0 pentru a incepe numaratoarea pana la aparitia urmatorul cuvant, se va initializa userWord cu sirul vid pentru a permite constructia unui nou cuvant de catre utilizator, in mod similar si gameWord care se va construi si el pe masura ce utilizatorul scrie cuvantul, iar variabila newWord devine false (acesta este folosita pentru a ne asigura ca noul cuvant generat va aparea o singura data, dupa afisare aceasta va deveni true pentru a nu permite aparitia repetata a cuvantului generat in intervalul de timp pana la urmatoarul cuvant).  
   Se va afisa un cuvant generat aleator folosind functia random() cu randomSeed setat pe unul dintre pinii neutilizati.( analogRead(0)). Utilizatorul va scrie in terminal cuvantul generat aleator. In cazul in care utilizatorul va apasa tasta backspace cat timp numarul de litere citite de utilizator este mai mare de 0, atunci cu fiecare apasare a tastei se va sterge o litera de la finalul cuvantului, daca nu mai sunt litere led-ul va devenii verde. Tasta backspace va fi folosita in cazul in care a fost realizata o greasala in scrierea cuvantului. In schimb daca tasta apasata nu este backspace, se va construi cuvantul scris de utilizator si cuvantul generat (fiecare litera va fi adaugata la finalul cuvantului, iar pozitia literei in cuvant va fi incrementata cu 1 pentru a permite memorarea unei noi litere). Se adauga o litera in cuvantul scris de utilizator, rezulta in adaugarea urmatoarei litere in cuvantul generat de joc, a.i. cele 2 cuvinte sa aiba in permanenta acelasi numar de litere.  
   In cazul in care cuvantul construit partial de catre utiliztaor si cel generat sunt identice, atunci led-ul ramane verde, in caz contrat led-ul va devenii rosu pentru a marca greseala. Daca utilizatorul reuseste sa scrie cuvantul corect in intervalul de timp stabilit atunci se va creste scorul si se va trece imediat la urmatorul cuvant. Trecerea imediata se va face folosind interruptCount caruia ii va fi data valoarea corespunzatoare nivelului de dificultate in care se afla jocul, pentru a se genera imediat un nou cuvant. La finalul rundei, in cazul in care timpul rundei s-a scurs sau daca s-a apasat butonul de stop se va afisa scorul obtinut.  
